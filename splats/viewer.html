<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Gaussian Splat Viewer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
    html, body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #0c0f13;
        color: #eeeeee;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #glcanvas {
        width: 100vw;
        height: 100vh;
        display: block;
        touch-action: none;
        cursor: grab;
    }
    #glcanvas:active {
        cursor: grabbing;
    }
    #hud {
        position: fixed;
        top: 12px;
        left: 12px;
        padding: 10px 14px;
        background: rgba(12, 15, 19, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        font-size: 13px;
        line-height: 1.4;
        pointer-events: none;
        max-width: 320px;
    }
    #hud strong {
        font-size: 14px;
    }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="hud">
    <strong>Gaussian Splat Viewer</strong>
    <div id="status">Loading PLY…</div>
    <div>Drag to orbit · Scroll to zoom · Double-click to reset</div>
</div>
<script>
(() => {
    "use strict";

    const canvas = document.getElementById("glcanvas");
    const statusEl = document.getElementById("status");
    const gl = canvas.getContext("webgl2", { antialias: false });
    if (!gl) {
        statusEl.textContent = "WebGL2 is required";
        return;
    }

    const FOV_Y = Math.PI / 3;

    const vertexSource = `#version 300 es\n`
        + `precision highp float;\n`
        + `layout(location = 0) in vec2 inCorner;\n`
        + `layout(location = 1) in vec3 inMean;\n`
        + `layout(location = 2) in vec3 inColor;\n`
        + `layout(location = 3) in vec3 inScale;\n`
        + `layout(location = 4) in vec4 inQuat;\n`
        + `layout(location = 5) in float inOpacity;\n`
        + `uniform mat4 uView;\n`
        + `uniform mat4 uProjection;\n`
        + `uniform vec2 uFocal;\n`
        + `out vec3 vColor;\n`
        + `out float vOpacity;\n`
        + `flat out vec2 vCenterNDC;\n`
        + `flat out mat2 vInvCov;\n`
        + `mat3 quatToMat(vec4 q) {\n`
        + `    vec4 n = normalize(q);\n`
        + `    float x = n.x;\n`
        + `    float y = n.y;\n`
        + `    float z = n.z;\n`
        + `    float w = n.w;\n`
        + `    float xx = x * x;\n`
        + `    float yy = y * y;\n`
        + `    float zz = z * z;\n`
        + `    float xy = x * y;\n`
        + `    float xz = x * z;\n`
        + `    float yz = y * z;\n`
        + `    float wx = w * x;\n`
        + `    float wy = w * y;\n`
        + `    float wz = w * z;\n`
        + `    return mat3(\n`
        + `        1.0 - 2.0 * (yy + zz), 2.0 * (xy - wz), 2.0 * (xz + wy),\n`
        + `        2.0 * (xy + wz), 1.0 - 2.0 * (xx + zz), 2.0 * (yz - wx),\n`
        + `        2.0 * (xz - wy), 2.0 * (yz + wx), 1.0 - 2.0 * (xx + yy)\n`
        + `    );\n`
        + `}\n`
        + `void main() {\n`
        + `    vec4 q = vec4(inQuat.xyz, inQuat.w);\n`
        + `    mat3 R = quatToMat(q);\n`
        + `    vec3 s2 = max(inScale * inScale, vec3(1e-6));\n`
        + `    mat3 scaleMat = mat3(\n`
        + `        s2.x, 0.0, 0.0,\n`
        + `        0.0, s2.y, 0.0,\n`
        + `        0.0, 0.0, s2.z\n`
        + `    );\n`
        + `    mat3 cov3d = R * scaleMat * transpose(R);\n`
        + `    mat4 view = uView;\n`
        + `    vec4 worldPos = vec4(inMean, 1.0);\n`
        + `    vec4 cam4 = view * worldPos;\n`
        + `    vec3 cam = cam4.xyz;\n`
        + `    mat3 view3 = mat3(view);\n`
        + `    mat3 covCam = view3 * cov3d * transpose(view3);\n`
        + `    float z = max(-cam.z, 1e-4);\n`
        + `    vec3 j0 = vec3(uFocal.x / z, 0.0, uFocal.x * cam.x / (z * z));\n`
        + `    vec3 j1 = vec3(0.0, uFocal.y / z, uFocal.y * cam.y / (z * z));\n`
        + `    vec3 covJ0 = covCam * j0;\n`
        + `    vec3 covJ1 = covCam * j1;\n`
        + `    float a = max(1e-8, dot(j0, covJ0));\n`
        + `    float b = dot(j0, covJ1);\n`
        + `    float c = max(1e-8, dot(j1, covJ1));\n`
        + `    float det = max(a * c - b * b, 1e-12);\n`
        + `    mat2 cov2d = mat2(a, b, b, c);\n`
        + `    mat2 invCov = mat2(c, -b, -b, a) / det;\n`
        + `    float trace = a + c;\n`
        + `    float disc = sqrt(max(0.0, 0.25 * trace * trace - det));\n`
        + `    float eig1 = max(1e-8, 0.5 * trace + disc);\n`
        + `    float eig2 = max(1e-8, 0.5 * trace - disc);\n`
        + `    vec2 axis1 = abs(b) > 1e-6 ? normalize(vec2(eig1 - c, b)) : vec2(1.0, 0.0);\n`
        + `    vec2 axis2 = vec2(-axis1.y, axis1.x);\n`
        + `    float radius1 = sqrt(eig1) * 3.0;\n`
        + `    float radius2 = sqrt(eig2) * 3.0;\n`
        + `    vec4 clipCenter = uProjection * cam4;\n`
        + `    vec2 offset = axis1 * (inCorner.x * radius1) + axis2 * (inCorner.y * radius2);\n`
        + `    vec4 clip = clipCenter;\n`
        + `    clip.xy += offset * clip.w;\n`
        + `    gl_Position = clip;\n`
        + `    vColor = inColor;\n`
        + `    vOpacity = inOpacity;\n`
        + `    vCenterNDC = clipCenter.xy / clipCenter.w;\n`
        + `    vInvCov = invCov;\n`
        + `}`;

    const fragmentSource = `#version 300 es\n`
        + `precision highp float;\n`
        + `in vec3 vColor;\n`
        + `in float vOpacity;\n`
        + `flat in vec2 vCenterNDC;\n`
        + `flat in mat2 vInvCov;\n`
        + `uniform vec2 uViewport;\n`
        + `uniform float uAlphaBoost;\n`
        + `out vec4 outColor;\n`
        + `void main() {\n`
        + `    vec2 fragNDC = vec2((gl_FragCoord.x / uViewport.x) * 2.0 - 1.0, (gl_FragCoord.y / uViewport.y) * 2.0 - 1.0);\n`
        + `    vec2 delta = fragNDC - vCenterNDC;\n`
        + `    float q = dot(delta, vInvCov * delta);\n`
        + `    float alpha = clamp(vOpacity * exp(-0.5 * q) * uAlphaBoost, 0.0, 1.0);\n`
        + `    if (alpha < 1.0 / 1024.0) { discard; }\n`
        + `    vec3 rgb = vColor * alpha;\n`
        + `    outColor = vec4(rgb, alpha);\n`
        + `}`;

    function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const log = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compile error: ${log}`);
        }
        return shader;
    }

    function createProgram(vertexSrc, fragmentSrc) {
        const vs = compileShader(gl.VERTEX_SHADER, vertexSrc);
        const fs = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const log = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error(`Program link error: ${log}`);
        }
        return program;
    }

    const program = createProgram(vertexSource, fragmentSource);
    gl.useProgram(program);

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    const quadCorners = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const quadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, quadCorners, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    const strideFloats = 14;
    const strideBytes = strideFloats * 4;
    const instanceBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, 1, gl.DYNAMIC_DRAW);

    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, strideBytes, 0);
    gl.vertexAttribDivisor(1, 1);

    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(2, 3, gl.FLOAT, false, strideBytes, 12);
    gl.vertexAttribDivisor(2, 1);

    gl.enableVertexAttribArray(3);
    gl.vertexAttribPointer(3, 3, gl.FLOAT, false, strideBytes, 24);
    gl.vertexAttribDivisor(3, 1);

    gl.enableVertexAttribArray(4);
    gl.vertexAttribPointer(4, 4, gl.FLOAT, false, strideBytes, 36);
    gl.vertexAttribDivisor(4, 1);

    gl.enableVertexAttribArray(5);
    gl.vertexAttribPointer(5, 1, gl.FLOAT, false, strideBytes, 52);
    gl.vertexAttribDivisor(5, 1);

    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    const uniforms = {
        view: gl.getUniformLocation(program, "uView"),
        projection: gl.getUniformLocation(program, "uProjection"),
        focal: gl.getUniformLocation(program, "uFocal"),
        viewport: gl.getUniformLocation(program, "uViewport"),
        alphaBoost: gl.getUniformLocation(program, "uAlphaBoost"),
    };

    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.depthMask(false);
    gl.clearColor(0.03, 0.035, 0.04, 1.0);

    function loadPLY(url) {
        return fetch(url).then((response) => {
            if (!response.ok) {
                throw new Error(`Failed to fetch PLY (${response.status})`);
            }
            return response.text();
        }).then(parsePLY);
    }

    function parsePLY(text) {
        const lines = text.split(/\r?\n/);
        let lineIndex = 0;
        function nextLine() {
            while (lineIndex < lines.length) {
                const raw = lines[lineIndex++];
                if (raw !== undefined) {
                    return raw.trim();
                }
            }
            return null;
        }
        const first = nextLine();
        if (!first || first !== "ply") {
            throw new Error("Not a PLY file");
        }
        let format = null;
        let vertexCount = 0;
        let inVertex = false;
        const propertyOrder = [];
        while (true) {
            const line = nextLine();
            if (line === null) {
                throw new Error("Unexpected EOF in header");
            }
            if (line === "end_header") {
                break;
            }
            if (!line || line.startsWith("comment")) {
                continue;
            }
            const parts = line.split(/\s+/);
            if (parts[0] === "format") {
                format = parts[1];
                if (format !== "ascii") {
                    throw new Error(`Unsupported PLY format: ${format}`);
                }
            } else if (parts[0] === "element") {
                inVertex = parts[1] === "vertex";
                if (inVertex) {
                    vertexCount = parseInt(parts[2], 10);
                    propertyOrder.length = 0;
                }
            } else if (parts[0] === "property" && inVertex) {
                propertyOrder.push(parts[parts.length - 1]);
            }
        }
        if (format !== "ascii") {
            throw new Error("Only ASCII PLY files are supported");
        }
        if (!vertexCount) {
            return { count: 0 };
        }
        const propIndex = Object.create(null);
        propertyOrder.forEach((name, idx) => { propIndex[name] = idx; });
        const required = ["x","y","z","red","green","blue","scale_x","scale_y","scale_z","qw","qx","qy","qz","opacity"];
        for (const name of required) {
            if (!(name in propIndex)) {
                throw new Error(`PLY is missing required property: ${name}`);
            }
        }
        const positions = new Float32Array(vertexCount * 3);
        const colors = new Float32Array(vertexCount * 3);
        const scales = new Float32Array(vertexCount * 3);
        const quats = new Float32Array(vertexCount * 4);
        const opacities = new Float32Array(vertexCount);
        const boundsMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
        const boundsMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
        let read = 0;
        while (read < vertexCount) {
            const raw = nextLine();
            if (raw === null) {
                break;
            }
            if (!raw) {
                continue;
            }
            const parts = raw.split(/\s+/);
            if (parts.length < propertyOrder.length) {
                continue;
            }
            const px = parseFloat(parts[propIndex.x]);
            const py = parseFloat(parts[propIndex.y]);
            const pz = parseFloat(parts[propIndex.z]);
            positions[read * 3 + 0] = px;
            positions[read * 3 + 1] = py;
            positions[read * 3 + 2] = pz;
            boundsMin[0] = Math.min(boundsMin[0], px);
            boundsMin[1] = Math.min(boundsMin[1], py);
            boundsMin[2] = Math.min(boundsMin[2], pz);
            boundsMax[0] = Math.max(boundsMax[0], px);
            boundsMax[1] = Math.max(boundsMax[1], py);
            boundsMax[2] = Math.max(boundsMax[2], pz);
            colors[read * 3 + 0] = parseInt(parts[propIndex.red], 10) / 255;
            colors[read * 3 + 1] = parseInt(parts[propIndex.green], 10) / 255;
            colors[read * 3 + 2] = parseInt(parts[propIndex.blue], 10) / 255;
            scales[read * 3 + 0] = parseFloat(parts[propIndex.scale_x]);
            scales[read * 3 + 1] = parseFloat(parts[propIndex.scale_y]);
            scales[read * 3 + 2] = parseFloat(parts[propIndex.scale_z]);
            const qw = parseFloat(parts[propIndex.qw]);
            const qx = parseFloat(parts[propIndex.qx]);
            const qy = parseFloat(parts[propIndex.qy]);
            const qz = parseFloat(parts[propIndex.qz]);
            quats[read * 4 + 0] = qx;
            quats[read * 4 + 1] = qy;
            quats[read * 4 + 2] = qz;
            quats[read * 4 + 3] = qw;
            opacities[read] = parseFloat(parts[propIndex.opacity]);
            read += 1;
        }
        return {
            count: read,
            positions,
            colors,
            scales,
            quats,
            opacities,
            bounds: { min: boundsMin, max: boundsMax },
        };
    }

    function vec3Sub(a, b) {
        return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }
    function vec3Add(a, b) {
        return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
    }
    function vec3Scale(v, s) {
        return [v[0] * s, v[1] * s, v[2] * s];
    }
    function vec3Dot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function vec3Cross(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0],
        ];
    }
    function vec3Length(v) {
        return Math.hypot(v[0], v[1], v[2]);
    }
    function vec3Normalize(v) {
        const len = vec3Length(v);
        if (len < 1e-8) {
            return [0, 0, 0];
        }
        const inv = 1 / len;
        return [v[0] * inv, v[1] * inv, v[2] * inv];
    }

    function lookAt(eye, center, up) {
        const f = vec3Normalize(vec3Sub(center, eye));
        const s = vec3Normalize(vec3Cross(f, up));
        const u = vec3Cross(s, f);
        const out = new Float32Array(16);
        out[0] = s[0];
        out[1] = u[0];
        out[2] = -f[0];
        out[3] = 0;
        out[4] = s[1];
        out[5] = u[1];
        out[6] = -f[1];
        out[7] = 0;
        out[8] = s[2];
        out[9] = u[2];
        out[10] = -f[2];
        out[11] = 0;
        out[12] = -vec3Dot(s, eye);
        out[13] = -vec3Dot(u, eye);
        out[14] = vec3Dot(f, eye);
        out[15] = 1;
        return { matrix: out, forward: f };
    }

    function perspective(fovY, aspect, near, far) {
        const f = 1 / Math.tan(fovY / 2);
        const out = new Float32Array(16);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = (2 * far * near) / (near - far);
        out[15] = 0;
        return { matrix: out, focal: [out[0], out[5]] };
    }

    function computeBoundsCenter(bounds) {
        return vec3Scale(vec3Add(bounds.min, bounds.max), 0.5);
    }

    function computeBoundsExtent(bounds) {
        return [
            bounds.max[0] - bounds.min[0],
            bounds.max[1] - bounds.min[1],
            bounds.max[2] - bounds.min[2],
        ];
    }

    const state = {
        data: null,
        order: [],
        depth: [],
        packed: null,
        scratch: null,
        camera: null,
        initialCamera: null,
    };

    function setupCamera(bounds) {
        const center = computeBoundsCenter(bounds);
        const extent = computeBoundsExtent(bounds);
        const maxExtent = Math.max(extent[0], extent[1], extent[2], 1e-3);
        const distance = maxExtent * 2.5;
        const camera = {
            target: center,
            distance: distance,
            minDistance: maxExtent * 0.2,
            maxDistance: maxExtent * 10,
            theta: Math.PI * 0.25,
            phi: Math.PI * 0.35,
        };
        state.camera = camera;
        state.initialCamera = { ...camera };
    }

    function cameraPosition(cam) {
        const sinPhi = Math.sin(cam.phi);
        const cosPhi = Math.cos(cam.phi);
        const sinTheta = Math.sin(cam.theta);
        const cosTheta = Math.cos(cam.theta);
        const dir = [
            sinPhi * cosTheta,
            cosPhi,
            sinPhi * sinTheta,
        ];
        const eye = vec3Add(cam.target, vec3Scale(dir, cam.distance));
        return { eye, dir: vec3Normalize(vec3Sub(cam.target, eye)) };
    }

    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }

    const pointer = {
        active: false,
        lastX: 0,
        lastY: 0,
        id: null,
        mode: null,
    };

    canvas.addEventListener("contextmenu", (event) => {
        event.preventDefault();
    });

    canvas.addEventListener("pointerdown", (event) => {
        pointer.active = true;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        pointer.id = event.pointerId;
        pointer.mode = (event.button === 2 || event.button === 1) ? "pan" : "rotate";
        canvas.setPointerCapture(event.pointerId);
        event.preventDefault();
    });

    function releasePointer(event) {
        if (pointer.id !== null && event.pointerId === pointer.id) {
            pointer.active = false;
            pointer.id = null;
            pointer.mode = null;
            try {
                canvas.releasePointerCapture(event.pointerId);
            } catch (err) {
                /* ignore */
            }
        }
    }

    canvas.addEventListener("pointerup", releasePointer);
    canvas.addEventListener("pointercancel", releasePointer);
    canvas.addEventListener("pointerleave", releasePointer);

    canvas.addEventListener("pointermove", (event) => {
        if (!pointer.active || pointer.id === null || event.pointerId !== pointer.id || !state.camera) {
            return;
        }
        if (event.buttons === 0) {
            releasePointer(event);
            return;
        }
        const dx = event.clientX - pointer.lastX;
        const dy = event.clientY - pointer.lastY;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        const cam = state.camera;
        if (pointer.mode === "pan") {
            const camInfo = cameraPosition(cam);
            let right = vec3Cross(camInfo.dir, [0, 1, 0]);
            if (vec3Length(right) < 1e-5) {
                right = [1, 0, 0];
            } else {
                right = vec3Normalize(right);
            }
            let upVec = vec3Cross(right, camInfo.dir);
            if (vec3Length(upVec) < 1e-5) {
                upVec = [0, 1, 0];
            } else {
                upVec = vec3Normalize(upVec);
            }
            const width = Math.max(canvas.clientWidth, 1);
            const height = Math.max(canvas.clientHeight, 1);
            const aspect = width / height;
            const verticalSpan = 2 * cam.distance * Math.tan(FOV_Y / 2);
            const horizontalSpan = verticalSpan * aspect;
            const panX = (dx / width) * horizontalSpan;
            const panY = (dy / height) * verticalSpan;
            cam.target[0] += -right[0] * panX + upVec[0] * panY;
            cam.target[1] += -right[1] * panX + upVec[1] * panY;
            cam.target[2] += -right[2] * panX + upVec[2] * panY;
        } else {
            cam.theta -= dx * 0.005;
            cam.phi = clamp(cam.phi - dy * 0.005, 0.05, Math.PI - 0.05);
        }
    });

    canvas.addEventListener("wheel", (event) => {
        if (!state.camera) {
            return;
        }
        event.preventDefault();
        const cam = state.camera;
        const factor = Math.exp(event.deltaY * 0.001);
        cam.distance = clamp(cam.distance * factor, cam.minDistance, cam.maxDistance);
    }, { passive: false });

    canvas.addEventListener("dblclick", () => {
        if (!state.initialCamera || !state.camera) {
            return;
        }
        Object.assign(state.camera, state.initialCamera);
    });

    window.addEventListener("keydown", (event) => {
        if (event.key === "r" && state.initialCamera && state.camera) {
            Object.assign(state.camera, state.initialCamera);
        }
    });

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const width = Math.floor(canvas.clientWidth * dpr);
        const height = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
        }
        gl.viewport(0, 0, width, height);
    }

    function prepareBuffers(data) {
        state.order = new Array(data.count);
        state.depth = new Float32Array(data.count);
        state.packed = new Float32Array(data.count * strideFloats);
        state.scratch = new Float32Array(data.count * strideFloats);
        for (let i = 0; i < data.count; i += 1) {
            state.order[i] = i;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, state.packed.byteLength, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    function sortInstances(cameraInfo) {
        const positions = state.data.positions;
        const depth = state.depth;
        const order = state.order;
        const eye = cameraInfo.eye;
        const dir = cameraInfo.dir;
        for (let i = 0; i < state.data.count; i += 1) {
            const px = positions[i * 3 + 0];
            const py = positions[i * 3 + 1];
            const pz = positions[i * 3 + 2];
            const vx = px - eye[0];
            const vy = py - eye[1];
            const vz = pz - eye[2];
            depth[i] = vx * dir[0] + vy * dir[1] + vz * dir[2];
            order[i] = i;
        }
        order.sort((a, b) => depth[b] - depth[a]);
    }

    function uploadInstances() {
        const order = state.order;
        const packed = state.packed;
        const scratch = state.scratch;
        const positions = state.data.positions;
        const colors = state.data.colors;
        const scales = state.data.scales;
        const quats = state.data.quats;
        const opacities = state.data.opacities;
        const stride = strideFloats;
        for (let i = 0; i < order.length; i += 1) {
            const idx = order[i];
            const dst = i * stride;
            scratch[dst + 0] = positions[idx * 3 + 0];
            scratch[dst + 1] = positions[idx * 3 + 1];
            scratch[dst + 2] = positions[idx * 3 + 2];
            scratch[dst + 3] = colors[idx * 3 + 0];
            scratch[dst + 4] = colors[idx * 3 + 1];
            scratch[dst + 5] = colors[idx * 3 + 2];
            scratch[dst + 6] = Math.max(scales[idx * 3 + 0], 1e-6);
            scratch[dst + 7] = Math.max(scales[idx * 3 + 1], 1e-6);
            scratch[dst + 8] = Math.max(scales[idx * 3 + 2], 1e-6);
            scratch[dst + 9] = quats[idx * 4 + 0];
            scratch[dst + 10] = quats[idx * 4 + 1];
            scratch[dst + 11] = quats[idx * 4 + 2];
            scratch[dst + 12] = quats[idx * 4 + 3];
            scratch[dst + 13] = opacities[idx];
        }
        packed.set(scratch);
        gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, packed);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    function renderFrame() {
        if (!state.data || !state.camera) {
            gl.clear(gl.COLOR_BUFFER_BIT);
            requestAnimationFrame(renderFrame);
            return;
        }
        resizeCanvas();
        const aspect = canvas.width / Math.max(canvas.height, 1);
        const projection = perspective(FOV_Y, aspect, 0.01, 100.0);
        const camInfo = cameraPosition(state.camera);
        const view = lookAt(camInfo.eye, state.camera.target, [0, 1, 0]);
        sortInstances(camInfo);
        uploadInstances();
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.bindVertexArray(vao);
        gl.uniformMatrix4fv(uniforms.view, false, view.matrix);
        gl.uniformMatrix4fv(uniforms.projection, false, projection.matrix);
        gl.uniform2f(uniforms.focal, projection.focal[0], projection.focal[1]);
        gl.uniform2f(uniforms.viewport, canvas.width, canvas.height);
        gl.uniform1f(uniforms.alphaBoost, 1.0);
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, state.data.count);
        gl.bindVertexArray(null);
        requestAnimationFrame(renderFrame);
    }

    loadPLY("/ply").then((data) => {
        if (!data.count) {
            statusEl.textContent = "PLY contains no splats";
            return;
        }
        state.data = data;
        setupCamera(data.bounds);
        prepareBuffers(data);
        statusEl.textContent = `Loaded ${data.count.toLocaleString()} splats`;
        requestAnimationFrame(renderFrame);
    }).catch((err) => {
        console.error(err);
        statusEl.textContent = `Failed to load: ${err.message}`;
    });
})();
</script>
</body>
</html>
