3DGS Completion Plan (without COLMAP)

Scope: Implement production-ready training around the existing rasterizer, using current inputs (images + calibrated intrinsics/extrinsics). Keep kernels unchanged; add missing policies, schedules, and tooling.

1) Screen-space footprint and error attribution
- Compute per-Gaussian screen-space footprint radius
  - From scales+quats form the 3D covariance Σ_w (diagonal(scales)^2 rotated by quats).
  - Project to screen: use Jacobian J of world→clip→NDC→pixel at the Gaussian mean; Σ_px = J Σ_w J^T.
  - Derive footprint radii from eigenvalues of Σ_px; use max radius in pixels; clamp to [r_min, r_max].
- Per-Gaussian screen-space error signal
  - Option A (fast heuristic): error_score = mean(|residual| in local neighborhood) × footprint_radius.
  - Option B (soft assignment): render weights or coverage mask per Gaussian (if exposed), accumulate residual-weighted error per Gaussian.
  - Cache/stream to avoid large memory overhead; compute on a downscaled grid if needed.

2) Split / Prune / Merge with strict budgets
- Split (clone) policy
  - Priority score: error_score × footprint_radius (or normalized by area).
  - Select top-K per densify step (clone_max), respecting global max_gaussians.
  - Clone with small random jitter; halve scales; copy SH coeffs and opacity.
- Prune policy
  - Remove Gaussians with: opacity < τ_opacity OR footprint_radius < r_min AND low contribution/error.
  - Optional age-based grace period before pruning new splats.
- Merge (optional but recommended)
  - Candidate pairs within d_merge in 3D and similar anisotropy; merge by error-weighted average of means/scales/quats/opacity; average SH.
  - Budget merges per step (merge_max) to bound time.
- Iteration budgets and ordering
  - For each densify step: prune → merge → split → enforce global cap; log changes and resulting N.

3) Schedules (stability and convergence)
- SH degree ramp
  - Start with degree 0; ramp to 2 at ~1k iters, then to 3/4 at later milestones.
  - Initialize new SH bands to zero; optionally reduce LR temporarily when ramping.
- Opacity resets
  - At milestones (e.g., every 2–3k iters), clamp or re-center opacity into [o_min, o_max], then resume learning to encourage visibility competition and remove floaters.
- LR schedules
  - Separate LRs for means vs other params; cosine/step decay; short warmup for stability.
  - Optional parameter-wise weight decay (lower or none for means; small for SH and scales).
- Regularizers
  - Screen-space scale penalty to avoid overly large splats (λ_scale * footprint_radius^2).
  - Opacity sparsity (λ_opacity * opacity^2 or L1); SH magnitude penalty (λ_sh * ||SH||^2), with annealing of λs over time.

4) Rasterization configuration and culling knobs
- Prefiltering toggle (default on) for anti-aliasing; expose near/far planes.
- Tile/binning/culling (if exposed by API)
  - Surface CLI knobs: tile_size, per_tile_max, cull_radius_px, max_splats_per_pixel.
  - Choose safe defaults that keep VRAM bounded; document trade-offs.

5) Metrics, logging, and safety
- Metrics: PSNR and SSIM per step or moving average; optional LPIPS offline.
- Log: step, loss terms, PSNR/SSIM, N gaussians, footprint stats (mean/min/max), RAM/VRAM usage, schedule states (current SH degree, LR, λs).
- OOM guardrails: progressive resolution early; AMP on; expandable_segments allocator; try-catch with graceful checkpoint on failure.

6) Checkpointing and resume
- Save: means, scales, quats, opacity, colors/SH, optimizer state, scaler (AMP), schedule state (current SH degree, LR stage, regularizer weights), and densify budgets.
- Resume: restore all above; verify shapes and SH degree; reconcile if ramp schedules changed (e.g., pad missing SH bands with zeros).

7) Presets (quality vs memory)
- memory_low: downscale=4, max_gaussians=1.5M, clone_max=20k, densify_add=100, prune τ=0.03, SH ramp to d=2, aggressive culling.
- balanced: downscale=2, max_gaussians=3M, clone_max=50k, densify_add=250, prune τ=0.02, SH ramp to d=3, default culling.
- quality_high: full res late, max_gaussians=6M, clone_max=75k, densify_add=500, prune τ=0.015, SH ramp to d=4, relaxed culling.

8) Implementation tasks (concrete)
- API/CLI
  - Add CLI flags for: r_min/r_max, τ_opacity, clone_max, prune_max, merge_max, split_interval, prune_interval, merge_interval, tile/binning knobs, schedule milestones (ramp steps, reset steps), regularizer weights.
- Engine
  - Implement footprint computation (Σ_w → Σ_px) and a fast approximation path.
  - Implement residual maps and error attribution (downscaled pass ok); cache per step.
  - Implement split/prune/merge with budgets and logging; integrate into existing densify step.
  - Add schedules: SH ramp, opacity resets, LR stages, regularizer annealing.
  - Extend optimizer param groups for schedule-driven LR changes; keep AMP scaler.
  - Update loss to L1+SSIM mix with regularizers; ensure no_grad for viz and progressive resolution.
- Tooling
  - Metric logging (CSV + optional TensorBoard); memory logging.
  - Checkpoint state extensions and resume path; migration for SH degree changes.
  - Preset config files (yaml/json) mapping to CLI flags.

Notes
- Keep global cap invariant after each densify cycle.
- Prefer deterministic ordering for selection (ties broken by stable keys) for reproducibility.
- Benchmark with fixed seeds on representative scenes; adjust budgets to avoid jitter in N.
